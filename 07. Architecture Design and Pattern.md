# 07. Architecture Design and Pattern

- 아키텍처: 구성 요소와 구성 요소 간의 통신에 관한 것
  - 클래스 수준 이상의 그룹화와 역할, 인터페이스를 정의하는 작업이다.
- 아키텍처 스타일: 구성 요소들의 역할과 관계가 잘 알려진 공통 유형
- 디자인 패턴: 자주 접하는 문제에 대한 설계 솔루션을 제공



## 7.1 아키텍처 기초

### 7.1.1 아키텍처란

- 소프트웨어 아키텍처: 시스템에서 높은 추상 수준의 구성 요소의 구조, 구성 요소의 관계, 연결 유형 및 상호 작용을 의미한다.
- 예) 웹 기반 시스템의 아키텍처: 클라이언트 서버
  - 웹 브라우저: 클라이언트 측 구성 요소
  - 웹 서버: 서버 측 구성 요소
  - 연결: HTTP 프로토콜
  - 클라이언트는 DNS(Domain Name System)을 사용하여 서버를 찾는다.
  - HTTP 프로토콜은 상태가 없으므로, 클라이언트와 서버는 상태 없는 연결이다.



### 7.1.3 아키텍처의 표현

- 아키텍처는 시스템의 추상적인 요약이므로, 불필요한 것을 생략하고 중요한 것에 집중할 수 있게 해준다.
- 계층적 분할(hierarchical decompositions): 상세 수준에 따라 나누어 표현된 컴포넌트를 분할하는 것



#### 7.1.3.1 패키지 다이어그램

- 패키지: 관련된 클래스를 그룹화한 것
- 소프트웨어 구조를 표현하는데 적합
- 패키지로 분할하는 방법은 다음과 같다.
  - (1) 같은 유스케이스에 발견된 객체는 같은 서브시스템으로 구분한다.
  - (2) 서브시스템 사이에 데이터를 전달하기 위해 사용되는 객체는 단독 서브시스템으로 만든다.
  - (3) 서브시스템 경계에 있는 연관 관계를 최소화한다.
  - (4) 같은 서브시스템 안에 있는 모든 객체는 기능적으로 연관이 있어야 한다.



## 7.2 아키텍처 스타일

- 아키텍처 스타일: 아키텍처의 유형이다.
  - 구성 요소 유형에 대한 설명 및 런타임 제어, 데이터 전송에 대한 패턴
  - 시스템 컴포넌트 유형과 그 상호 작용 패턴에 대한 제약



### 시스템의 타입

시스템의 타입은 네 가지로 나눌 수 있다.

- (1) **대화형(interactive)** 시스템: 가장 보편적이다.
  - 예) 사용자가 링크를 클릭하면 시스템이 로그인 페이지를 보여준다.
  - (1) 액터가 구동시키는 비지니스 프로세스를 나타내는 유스케이슬르 찾아내고 명세화한다.
  - (2) 시스템 안에 있는 객체들이 이를 위해 어떻게 협력하고 상호작용하는지 상세하게 모델링한다.
  - 아키텍처는 유스케이스 단위로 구성되고 컴포넌트화한다.
- (2) **이벤트 중심(event-driven)** 시스템: 상태에 의존적이며 반응 동작을 보인다.
  - 예) 임베디드 시스템: 소프트웨어는 장치에 의해 불규칙적으로 생성된 이벤트를 받아 처리하고 제어하기 위한 명령을 발생시킨다.
  - 상태 다이어그램으로 모델링하고 상태 단위로 아키텍처가 구성된다.
- (3) **변환(transformational) 시스템**
  - 예) 컴파일러: 원시 코드를 실행 코드로 바꾼다.
- (4) **객체 영속(object-persistence)** 시스템: 저장 미디어를 숨기고 디비와 파일 시스템에 객체를 저장하고 검색할 수 있는 시스템
  - 분산 시스템이라고도 한다.



### 7.2.1 클라이언트 서버형

- 클라이언트 서버 아키텍처에서 네트워크에 연결된 모든 개체는 클라이언트 혹은 서버이다.
- 서버: 자원을 관리하며 클라리언트가 요청하는 기능이나 자원을 제공한다. 다수의 클라이언트에 서비스한다.
  - 서버의 자원: 데이터, CPU, 프린터 등
- 클라이언트: 단일한 사용자 시스템으로 자원의 사용을 위해 서버를 접속하는 애플리케이션이 존재한다.
  - 서로 통신하지 않고 서버를 통해 간접적으로 통신할 수 있다.
- 클라이언트 서버 스타일의 종류
  - 3-계층: N-계층은 프레젠테이션, 애플리케이션 처리, 데이터 관리 기능이 분리된 모델
  - 무거운 클라이언트: 서버는 자료 제공 등 일부만 담당한다.
  - 가벼운 클라이언트: 클라이언트는 UI 프레젠테이션만 담당한다.

- 장점
  - 데이터 집중화: 모든 데이터는 서버에 모아 데이터의 구성과 관리를 단순화한다. 데이터의 백업과 변경/편집이 쉽다.
  - 보안: 클라이언트의 요청을 모니터링하고 기록할 수 있다. 인증을 마친 클라이언트만 특정 서비스에 접근할 수 있도록 검증한다.
- 단점
  - 병복: 서버와 통신하려는 클라이언트가 증가하면 서버의 부하가 올라간다.
  - 비용: 설치 및 관리 비용이 일반적으로 높다.
  - 비강인성: 서버가 고장 나면 클라이언트는 작동할 수 없다.



### 7.2.2 계층형

- 계층형 스타일: 소프트웨어의 기능을 수직으로 상호 작용하는 여러 층으로 분할한다.
  - 각 층은 기능이 명확하게 정해져있다.
  - 각 층 사이는 메시지를 교환한다. 
  - 각 층은 바로 위나 아래층에만 메시지를 보내고 받는다.

- 장점
  - 추상화: 시스템에 대해 추상적인 뷰를 제공한다. 각 층의 역할, 책임, 관게를 이해하기 쉽다.
  - 캡슐화, 응집, 결합: 각 층의 응집이 높고 층 사이의 결합이 적다.
  - 재사용성: 각 층의 의존도가 적어 쉽게 다른 모듈로 교환할 수 있고 다른 시스템에 사용가능하다.
- 단점
  - 이웃한 층과의 커뮤니케이션이 제한적이다.
  - 결합력이 낮아 시스템을 계층으로 구성하기 어렵다.



### 7.2.3 이벤트 기반 아키텍처

- 이벤트 기반 아키텍처: 이벤트 스트림을 생성하는 이벤트 생성자와 이벤트를 수신 대기하는 이벤트 소비자로 구성된다.
- 생상자와 소비자가 분리되어 생산자는 수신 대기 중인 소비자를 알 수 없다.
- 상태 기반 처리를 바탕으로 한다: 발생된 이벤트의 종류와 현재 시스템의 상태에 따라 다른 처릴르 한다.
- 이벤트 기반 아키텍처 스타일
  - 콜백 혹은 암시적 호출이라고 한다.
  - (1) 클라이언트가 이벤트에 관심을 등록하는 통신 방법을 사용한다.
  - (2) 이벤트 발생시 이벤트 소스가 청취 클라이언트에 대한 메서드를 통지하거나 호출한다.
- 장점
  - 캡슐화, 응집: 이벤트의 생산자와 소비자가 분리되어 캡슐화된다.
  - 확장성: 시스템에 새 소비자를 쉽게 추가할 수 있다.
  - 이벤트가 도착하는 즉시 소비자가 이벤트에 응답할 수 있다.
  - 하위 시스템에서 이벤트 스트림을 독립적으로 확인할 수 있다.
- 단점
  - 복잡성: 상태에 따라 복잡하고 정교한 제어가 필요하다.
  - 테스팅: 각 상태에 허용된 이벤트가 제한적인 것을 정확히 테스트해야 하며 적용되지 않은 이벤트에 대해 적절한 오류 메시지와 제어가 필요하다.



### 7.2.4 MVC

- MVC(Model-View-Controller): 사용자 인터페이스로부터 비지니스 로직을 분리한다.
- MVC는 응용 프로그램을 세 가지의 구성 요소로 나눈다.
  - 컨트롤러: 모델에 명령을 보내어 모델의 상태를 변경한다.
  - 모델: 데이터 상태에 변화가 있을 때 컨트롤러와 뷰에 이를 통보한다.
  - 뷰: 사용자가 볼 결과물을 생성하기 위해 모델로부터 데이터를 얻어온다.
- 장점
  - 느슨한 결합, 확장성: 각 컴포넌틔 결합이 약해 다른 부분에 영향을 주지 않고 수정할 수 있다.
  - 다수의 다른 뷰: 하나의 모델을 위해 다수의 다른 뷰를 쉽게 제공할 수 있다. 데이터와 비지니스 로직이 분리되어 코드 중복이 적다.
  - 비동기: 비동기 기술로 애플리케이션을 빠르게 로딩할 수 있다. 컴포넌트를 독립적으로 빠르게 개발할 수 있다.
- 단점
  - 복잡도: 컴포넌트를 분리하여 메커니즘을 이해하기 어렵다.
  - 비효율성: 뷰에서 데이터를 접근해야 하는 부분이 있다.
  - 각 컴포넌트 구현을 위해 여러 기술에 대한 이해가 필요하다.



### 7.2.5 파이프 필터

- 파이프 필터 아키텍처: 필터 사이에 데이터를 이동시켜 단계적으로 처리리한다.
  - 데이터의 흐름(입력, 출력)과 데이터의 변환을 수행하는 필터들로 구성되어 있다.
- 예) 컴파일러
  - 어휘 분석기: 문자 스트림을 토큰으로 변환
  - 구문 분석기: 토큰으로 구문 트리를 작성
  - 의미 분석기: 구문 정보에 구문 트리 주석을 단다.
  - 코드 생성기: 구문 트리에서 코드를 생성한다.
- 배치 처리(batch processing): 파이프 필터의 변형
  - 다음 단계를 처리하기 전 앞 단게가 완료되어야 한다.
- 장점
  - 단순성: 시스템을 일련의 입력, 출력, 변환으로 볼 수 있다.
  - 재사용: 필터를 재사용할 수 있고 교체할 수 있다.
  - 병렬성: 벙렬 처리로 구현하기 쉬운 아키텍처를 제공
- 단점
  - 자원의 낭비: 시간과 공간을 낭비할 수 있음.
    - 데이터는 이동할 때 여러 곳에 저장됨
    - 각 필터는 입력, 출력 형식으로 변환해야 함
  - 오류 조건을 쉽게 처리할 수 있는 방법이 없음: 별도의 출력 스트림으로 처리해야 함



### 7.2.6 데이터 중심 아키텍처

- 두 가지 요소로 구성된다.
  - 데이터 저장소
  - 공유 데이터 접근자: 공유 데이터를 추가, 삭제, 수정함. 서로 모른다. 공유 데이터에 대한 업데이트를 통해 간접적으로 통신을 수행
- 데이터 중심 스타일에 속하는 아키텍처 스타일
  - 블랙 보드
    - 공유 데이터에 제어 스레드가 포함된다.
    - 공유 데이터 저장소: 옵저버 디자인 패턴을 사용, 공유 데이터가 변경될 때 클라이언트에게 공지함
  - 리파지토리: 클라이언트가 공유 데이터를 질의하여 변경 사항을 발견
- 장점
  - 낮은 결합: 접근자 간의 느슨한 결합을 유지
  - 확장성: 각 접근자를 수정하고 확장하기 쉽다.
- 단점
  - 단일 장애 지점이 존재한다: 공유 데이터의 장애로 전체가 장애를 일으킬 수 있음.



### 7.2.7 Peer-to-Peer 스타일

- 모든 엔드 시스템에 동등한 기능과 책임이 있음: 모든 컴포넌트는 동등하여 클라이언트와 서버 역할을 할 수 있다. 각 컴포넌트 자원 제공자이자 자원이다.
- 장점
  - 전담하는 애플리케이션이나 서버가 없다.
  - 규모 확장성과 신뢰성이 개선: 컴포넌트에 고장이 있어도 전체 시스템이 가동된다.
- 단점
  - 보안 취약
  - 중앙 제어 불가능
  - 공유된 자원으로 성능이 저하





![7.1_2 아키텍처 스타일의 비교](\image\7.1_2 아키텍처 스타일의 비교.jpg)

![7.1_1 아키텍처 스타일의 비교](\image\7.1_1 아키텍처 스타일의 비교.jpg)



## 7.3 디자인 패턴

- 디자인 패턴: 아키텍처 셀계 수준보다 낮은 수준의 설계 문제에 재사용 가능한 솔루션을 제공한다.



### 7.3.1 디자인 패턴의 혜택

- (1) 쉽게 재사용 가능하다: 여러 응용에서 디자인 솔루션을 재사용할 수 있는 방법을 제공한다.
- (2) 설계 작업이 쉬워진다
- (3) 설계 관련 지식이 정리된다
- (4) 디자인을 논의하기 위한 의사소통이 쉬워진다.
- (5) 객체지향 설계 원리를 잘 따르게 된다.



### 7.3.2 디자인 패턴의 형식

소프트웨어 디자인 패턴은 다음 형식으로 설명한다.

- 패턴 이름
- 소개: 배경을 정의하고 패턴을 학습하는 동기를 제공
- 해결하는 문제: 디자인 패턴이 적용되는 문제
- 솔루션: 실제 코드보다 추상적인 설계 조각
- 예제
- 관련 패턴: 유사한 패턴과 구분하기 위한 설명



### 7.3.3 싱글톤 패턴

해결하는 문제

- 한 클래스에 대해 생성된 객체 수를 제한
- 하나의 클래스 인스턴스만 원하고 모든 클라이언트가 동일한 인스턴스를 공유

솔루션

- 정적 속성으로 유일한 객체 생성
- 생성된 객체를 반환하는 정적 메서드

관련 패턴

- 추상 팩토리 패턴과 사용: 최대 하나의 팩토리 클래스가 생성되도록 보장
- 상태 패턴과 사용: 상태가 전환될 때 상태 클래스가 다시 생성되지 않도록



### 7.3.4 반복자 패턴

반복자(iterator) 패턴

- 객체 그룹과 연관된 집합 클래스(컨테이너 클래스 또는 컬렉션 클래스)와 사용
- 집합 클래스의 자료구조와 상관없이 집합에 소속된 요소들에 쉽게 접근할 수 있음

해결하는 문제

- 반복자를 정의: 내부적인 구현에 관계없이 집합 요소에 순차적으로 액세스하는 방법 제공

솔루션

- (1) 반복 수행하는 집합 클래스에 대해 접근하는 반복자를 `Iterator` 인터페이스로 정의한다.
- (2) 집합에 의해 구현될 `Aggregate` 인터페이스를 정의한다. 반복자를 반환하는 팩토리 메서드를 포함해야 한다.
- (3) 추상 팩토리 메서드를 상속 구현: 특정 집합의 반복자를 반환하는 집합 클래스 작성
- (4) `Iterator`, `Aggregate` 인터페이스를 이용하는 클라이언트 코드 작성

사례

- 자바의 `Collection` 인터페이스를 구현한 집합 클래스 `ArrayList`, `LinkedList`
  - 배열과 연결 리스트 보관
  - `hasNest()`, `next()`, `remove()` 메서드 정의



### 7.3.5 어댑터 패턴

해결하는 문제

- 클라이언트와 서비스가 호환되지 않는 인터페이스를 가지고 있을 때 사용

솔루션

- 클라이언트가 기대하는 인터페이스를 구현한 어댑터 클래스를 작성

관련 패턴

- 퍼싸드 패턴과 유사: 이미 존재하는 인터페이스를 우회하여 정의



### 7.3.6 데코레이터 패턴

데코레이터 패턴: 집합 관계와 위임을 사용하여 기존 클래스의 동작을 가볍고 유연하게 확장

해결하는 문제

- 구성(composition) 관계를 사용함
  - 상속을 이용하면 컴파일할 때 동작이 확정된다.
  - 클래스의 동작을 클래스에 동적으로 동작을 추가할 수 없는 문제를 해결



### 7.3.7 팩토리 메서드 패턴

팩토리 메서드 패턴: 클래스의 새로운 객체를 생성할 때 사용

해결하는 문제

- 클라이언트에서 사용할 클래스의 객체를 생성하는 책임을 분리

솔루션

- (1) 팩토리 메서드로 생성될 새로운 객체를 위한 추상 인터페이스를 정의한다.
- (2) 클라이언트는 해당 인터페이스로 객체를 참조한다.
- (3) 팩토리 메서드를 포함하는 추상 클래스를 정의한다.
- (4) 클라이언트는 해당 인터페이스로 객체를 생성한다.
- (5) 각 객체 유형을 생성하는 팩토리 메서드를 구현한 구체적 클래스를 정의한다.



### 7.3.8 추상 팩토리 패턴

추상 팩토리 패턴: 클래스 외부로 객체를 만드는 책임을 위임한다.

- 클라이언트는 언제 객체를 만들지 결정하고 어떤 클래스를 만들지는 클라이언트 외부의 다른 클래스에서 결정한다.

해결하는 문제

- 객체를 사용할 클라이언트에서 구체적인 객체 생성을 지정하는 책임을 분리한다.
- 추상 인터페이스를 이용하여 관련 객체 패밀리를 작성하는 방법을 해결한다.

솔루션

- (1) 사용하려는 모든 Product에 대하여 추상 인터페이스를 정의한다.
- (2) 관련 Product 그룹을 만들기 위해 추상 팩토리 클래스를 정의한다.
- (3) 각 관련 Product 그룹에 대해 추상 팩토리 인터페이스를 구현한 클래스를 작성하고 함께 사용되는 패밀리를 작성한다.
- (4) 클라이언트: Product의 추상 인터페이스 및 추상 팩토리 인터페이스에 밀접하게 연결, 특정 Product 및 특정 Product 팩토리에 느슨하게 연결



### 7.3.9 상태 패턴

- 상태 패턴: 메서드의 교환에 초점을 둔다. 객체가 내부 상태에 따라 동작이 변경될 때 사용한다.

해결하는 문제

- 조건문에 기반한 상태 시스템은 프로그램이 커짐에 따라 유지보수가 어렵다.

솔루션

- (1) 객체가 가질 수 있는 모든 상태에 대하여 클래스를 만든다.
- (2) 모든 상태별 동작을 상태 클래스에서 관리한다.

관련 패턴

- 전략 패턴과의 차이: 상태 패턴은 상태들이 서로 인식한 상태에서 다른 상태로 전환한다. 전략 패턴을 서로를 잘 알지 못한다.



### 7.3.10 옵서버 패턴

옵저버 패턴: Subject 객체가 옵저버 객체와 느슨하게 결합되는 방법을 제공

해결하는 문제

- 데이터(Subject)가 변경될 때마다 옵저버에게 통지하므로 결합이 느슨하다.
- 옵저버는 Subject나 다른 옵저버에게 영향을 주지 않고 변경하거나 추가할 수 있다.

솔루션

- (1) 데이터를 가지고 있는 Subject를 정의한다.
- (2) Subject 클래스는 데이터에 관심 있는 옵저버 목록을 유지한다.
- (3) Observer 인터페이스에 변경 사항을 알리면 내용을 받아갈 수 있는 콜백 메서드를 정의한다.
- (4) Subject에 옵저버로 등록한 옵저버는 Observer 인터페이스를 구현한다.



## 7.4 아키텍처 평가

- 아키텍처 평가: 소프트웨어 아키텍처나 디자인 패턴의 속성, 강점 및 약점을 결정한다.
  - 아키텍처가 기능적 및 비기능적 품질 요구 사항을 모두 충족시킬 수 있는지 보증한다.



### 7.4.1 SAAM

- 시나리오 기반 평가 방법: 일련의 시나리오로를 실행할 수 있는지로 아키텍처의 기능을 평가
- 시나리오: 이해 관계자와 시스템의 상호 작용에 대한 간단한 설명
- 시나리오 사례: 시나리오는 두 가지로 구분된다.
  - 직접 시나리오: 시스템의 변경이 요구되지 않는 시나리오. 다음을 평가한다.
    - 유스케이스에 대한 아키텍처 지원
    - 인터페이스에 의하여 지원되는 보통 기능들
  - 간접 시나리오: 시스템의 변경이 요구되는 시나리오. 다음을 평가한다.
    - 새로운 기능 추가하거나 변경할 때 아키텍처가 지원하는지
    - 새로운 환경에 적응하는지
    - 재구조화할 때 아키텍처가 수용할 수 있는지



### 7.4.2 ATAM

- ATAM(Architecture Trade-off Analysis Method): 아키텍처의 트레이드오프(타협점)을 찾아내고 내부에 숨어 있는 리스크를 발견한다.
- 유틸리티 트리: 품질  특성 목표를 파악하고 이에 대한 우선순위와 시나리오를 작성



![7.2 유틸리티 트리와 시나리오](\image\7.2 유틸리티 트리와 시나리오.jpg)

