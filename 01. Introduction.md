# 01. Introduction

## 1.1 Software

### 1.1.1 소프트웨어

#### 소프트웨어의 정의

**소프트웨어**: 프로그램과, 프로그램의 개발, 운용, 보수에 필요한 정보의 일체



#### 소프트웨어의 특징

소프트웨어의 특징은 아래와 같다.

- (1) **복잡성(complexity)**: 자동화하려는 대상이 복잡하고, 내부 요소과 그 상호작용이 복잡함
- (2) **순응성(conformity)**: 환경, 변화에 따라 적절히 변형됨
- (3) **변경성(changeability)**: 쉽게 변경할 수 있고 자주 변경됨
- (4) **비가시성(invisibility)**: 그 구조가 코드 안에 숨어 있음



#### 소프트웨어의 종류

소프트웨어의 종류는 다음과 같다.

| 소프트웨어의 종류 | 특징                                                         | 사용되는 카피의 수 | 요구되는 하드웨어의 성능 | 필요한 개발 인력 |
| ----------------- | ------------------------------------------------------------ | ------------------ | ------------------------ | ---------------- |
| **주문형**        | 특정 사용자의 수요, 요구를 만족시키기 위하여 개발된 소프트웨어 | 적음               | 낮음                     | 많음             |
| **패키지형**      | (1) COTS(Commerical Off-The-Self) 소프트웨어: 패키지화하여 상업적으로 판매되는 소프트웨어<br />(2) 범용 컴퓨터에서 실행되는 범용 소프트웨어: 특정 사용자의 요구에 꼭 맞지 않을 수 있음<br />(3) 예: 워드프로세스, 운영체제 등 | 중간               | 높음                     | 중간             |
| **임베디드**      | 하드웨어 장치에 내장된 소프트웨어: 하드웨어를 교체하지 않는 한 소프트웨어를 업그레이드하기 어렵다. | 많음               | 중간                     | 적음             |



### 1.1.2 시스템

#### 시스템의 정의

**시스템**: 필요한 기능을 실현하기 위하여 관련 요소를 어떠한 법칙에 따라 조합한 집합체



#### 시스템의 특징

시스템의 특징은 아래와 같다.

- (1) **서브시스템**: 시스템은 밀접하게 관련된 서브시스템들로 구성된다.
- (2) **기능적 분할**: 시스템은 규모가 작은 서브시스템으로 나눌 수 있다.
- (3) **시스템 경계**: 시스템과 주변 환경을 구분하는 경계로서, 입력과 출력이 만나는 곳이다.
- (4) **자동화 경계**: 시스템에서 자동화된 부분과 수동 작업 부분을 나누는 경계이다.



## 1.2 소프트웨어 개발 작업

### 1.2.1 기본 활동

<img width="432" alt="1 3" src="https://user-images.githubusercontent.com/57662010/138551586-0c601035-c160-44db-804c-fae3997efe8e.PNG">

소프트웨어 개발과 사용까지 필요한 기본적인 활동들은 아래와 같다.

- (1) **명세화(specification)**: 제품 작동 방식, 포함해야 할 기능, 성능 요구 등을 합의하여 문서화
- (2) **구현(coding)**: 시스템의 명세를 설계하여 프로그래밍 언어로 변환
- (3) **검증(verification)**: 구현된 소프트웨어가 고객의 의도와 일치하는지 확인
- (4) **유지보수(maintenance)**: 개발된 이후 결함을 수정하고 기능을 개선



### 1.2.2 개발 작업의 어려움

- (1) 명세화의 어려움: 요구를 정확히 이해하고 정의하기 어려움
- (2) 재사용의 어려움: 미리 재사용할 컴포넌트를 만들기 어려움
- (3) 예측의 어려움: 소프트웨어가 여러 외부 요소의 영향을 받아 견적과 규모를 예측하기 어려움
- (4) 유지보수의 어려움: 다른 사람이 작성한 소프트웨어는 쉽게 이해하기 어려움
- (5) 고품질의 어려움: 하나의 코드를 테스트하는 것에도 무수히 많은 요소가 관련됨



#### 소프트웨어의 위기(software crisis)

- 소프트웨어 공학 초기에 사용되던 용어. 소프트웨어의 수요와 복잡성이 급격하게 증가하였으나 기존의 방법으로는 그 요구를 충족하기 어려워 발생한 문제



## 1.3 소프트웨어 공학의 접근법

- 즉흥적인 소프트웨어 개발: 코딩과 수정(code-and-fix)의 작업
- 즉흥적인 소프트웨어 개발의 문제점
  - (1) 개발이 지연되고 예산이 초과됨: 요구가 명확하지 않아 수정이 반복될 수 있음
  - (2) 품질이 낮음: 인간의 실수를 예측할 수 없음
  - (3) 유지보수가 곤란함: 잘 구조화하지 않으면 수정이 어려움
  - (4) 재작업: 잘 구조화하지 않으면 불가피하게 다시 개발해야할 수 있음



### 1.3.1 소프트웨어 공학의 정의

- **소프트웨어 공학**: 소프트웨어를 개발하기 위해 체계적으로 접근하고 원리를 적용하는 것
  - 체계적: 유사한 방법론(프로세스)을 사용하여 유사한 소프트웨어를 만드는 것
- 소프트웨어의 품질은 인력, 프로세스, 기술이 좌우한다.



### 1.3.2 소프트웨어 공학의 목표

- (1) 프로젝트의 복잡도를 낮춘다
- (2) 개발 비용을 최소화한다.
- (3) 개발 기간을 단축한다
- (4) 대규모 프로젝트를 관리한다
- (5) 고품질의 소프트웨어를 개발한다
- (6) 표준화를 통하여 개발을 효율적으로 진행한다.
- 즉, '원리와 방법'을 적용하여 <u>좋은 품질의 소프트웨어를 최소한의 비용으로 계획된 일정에 맞추어 개발</u>하는 것



## 1.4 소프트웨어 공학의 주제

소프트웨어 공학은 그 목표를 달성하기 위하여 세 가지 작업으로 나누어볼 수 있다.

- (1) **단계적 프로세스**: 소프트웨어를 구현할 때까지 정해진 순서로 작업을 수행한다.
- (2) **품질 보증**: 개발 작업이 적절히 수행되었는지 확인한다.
  - 소프트웨어 품질 보증(Software Qulaity Assurance)라고도 한다.
- (3) **프로젝트 관리**: 개발과 품질 보증 작업을 관리한다.



### 1.4.1 단계적 프로세스

- **단계적 프로세스**: 소프트웨어를 정해진 절차에 따라 작업하는 것
- 정해진 절차는 아래와 같다.
- (1) **요구 분석**: 해결해야할 문제를 분석하여 사용자의 요구를 추출한다.
  - 시스템이 가져야할 기능, 성능, 제약 사항 등을 파악한다.
  - 요구 명세서(requirement sepcification)를 작성한다.
- (2) **설계**: 요구 명세에 기술된 문제의 솔루션을 기술한다.
- (3) **구현(코딩)**: 설계를 기반, 프로그래밍 언어로 원시코드를 작성한다.
- (4) **테스팅**: 개발된 소프트웨어에 결함이 있는지 검토한다.



### 1.4.2 품질 보증

- **품질 보증**: 소프트웨어가 요구와 품질 수준을 만족하는 검토, 확인, 테스팅한다.
- (1) **검토(verification)**: 각 단계의 작업이 절차와 방법에 맞게 진행되었는지 확인한다.
- (2) **확인(validation)**: 결과물이 품질 수준에 맞게 생산되었는지 검사한다.
- (3) **테스팅(testing)**: 소프트웨어를 실행하여 예상대로 작동하는지 확인한다.



#### 바람직한 소프트웨어가 가져야할 특징

바람직한 소프트웨어가 가져야할 특징은 아래와 같다.

- (1) **유지보수성**: 고객의 요구에 맞게 소프트웨어를 수정해야한다.
- (2) **신뢰성**: 시스템이 장애를 일으켰을 때 손실을 발생시키지 않는 성질, 보안과 안전을 포함한다.
- (3) **효율성**: 메모리와 같은 시스템 자원을 낭비하지 않는 성질
- (4) **유용성**: 사용자가 쉽게 사용할 수 있는 특성



### 1.4.3 프로젝트 관리

#### 14.3.1. 소프트웨어 프로젝트에 대한 제약 조건

<img width="247" alt="1 11" src="https://user-images.githubusercontent.com/57662010/138552889-5fa1488a-ea94-49b3-9cc7-c10228d15131.PNG">

소프트웨어 프로젝트에 대한 세 가지 제약 조건은 다음과 같다.

- (1) **시간**
- (2) **범위**
- (3) **비용**

이들은 프로젝트 결과에 영향을 미치지 않아야 한다.



#### 14.3.2 프로젝트 관리 활동

**프로젝트 관리 활동**은 크게 네 가지로 나눌 수 있다.

- (1) **프로젝트 계획**: 소프트웨어 개발 전, 소프트웨어의 범위와 타당성을 검토하고 방법과 일정 등을 계획한다.
- (2) **자원 관리**: 소프트웨어를 개발하는 데 필요한 자원을 관리한다.
- (3) **리스크 관리**: 개발 중의 위험 요소를 예측하고 대비한다.
- (4) **프로젝트 수행과 모니터링**: 프로세스대로 개발이 진행되는 지 검사한다.



#### 14.3.3 소프트웨어 공학의 연구 결과

| 주제                   | 의미                                     | 사례                                                         |
| ---------------------- | ---------------------------------------- | ------------------------------------------------------------ |
| **방법(method)**       | 소프트웨어 개발에 사용하는 방법이나 절차 | (1) 구조적 분석, 설계 방법<br />(2) 객체지향 분석, 설계 방법 |
| **도구(tool)**         | 자동화된 시스템                          | (1) 설계 도구<br />(2) 프로그래밍 도구<br />(3) 테스트 도구  |
| **프로세스(process)**  | 도구와 방법을 사용하여 작업하는 순서     | (1) unified process<br />(2) Xtreme programming              |
| **패러다임(paradigm)** | 접근 방법과 스타일                       | (1) 구조적 방법론<br />(2) 객체지향 방법론                   |



## 1.5 연관 분야

- 소프트웨어 공학 지식 체계(SWEBOX; Sofware Engineering Body of Knowledge)
- 소프트웨어 공학은 <u>(1) 컴퓨터 공학의 원리나 기술과 관련된 원리를 다루는 분야</u>와 <u>(2)이를 적용하여 특정 문제를 해결하려는 응용 도메인 분야</u>를 연결한다.



### 1.5.1 연관 지식 영역

SWEBOK v3.0에서 정의하는 연관 지식 영역은 다음과 같다.

- (1) 소프트웨어 공학 전문가 기량(Software Engineering Professional Pratice): 전문성 등
- (2) 소프트웨어 공학 경제학
- (3) 컴퓨팅 기반: 문제해결 기술, 추상화, 프로그래밍 기초, 알고리즘, 자료구조 등
- (4) 수학적 기반: 집합, 관계, 함수, 그래프와 트리 등
- (5) 공학적 기반: 경험적 기법, 통계 분석 등



### 1.5.2 소프트웨어 공학과 컴퓨터 과학

- 컴퓨터 과학: 계산적 효율, 자원 공유, 정확성, 최적화, 성능 등을 강조. 이를 개선하기 위하여 알고리즘, 원리 등을 다룬다.
- 소프트웨어 공학: <u>생산성, 품질, 비용, 시간</u>을 강조한다.
- 하지만 컴퓨터 과학과 소프트웨어 공학은 매우 밀접하다.

