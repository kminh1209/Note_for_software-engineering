# 05. Requirement Modeling

요구 분석은 다음와 같은 시스템 사양을 작성하는 프로세스를 말한다.

- (1) 문제의 시스템과 관련하여 고객의 요구를 만족시키기 위한 사양
- (2) 시스템을 구축하기에 충분한 정보를 제공하는 사양



요구 모델링은 위 두 가지 속성을 만족하는 시스템 명세를 작성한다.

- (3) 명세는 사용자와 개발자가 동일한 방식으로 이해해야 한다.



요구 모델링과 요구 분석의 차이

- 요구 모델링은 사용자와 개발자가 무엇이 개발되고 있는지 동의하는 것을 주된 목적으로 하는 요구 명세를 만든다.
- 요구 분석은 구축중인 시스템에 대한 형식적 또는 준 형식적 설명을 제공한다.



요구 모델링과 요구 분석, 요구 명세의 관계

- **요구 분석 작업**: <u>문제 영역</u>에 있는 것들 중 시스템에 구현할 것들만을 골라 요구로 정의하는 작업
- **요구 모델링**: 개발자가 이해하는 <u>솔루션 영역</u>에서 요구를 표현
- **요구 명세**: 요구 모델링 작업에 의한 결과로, <u>문제 영역과 솔루션 영역이 만나는 인터페이스</u>에 해당



## 5.1 모델링 기초

### 모델링을 하는 이유

소프트웨어 시스템을 모델링하는 이유는 다음과 같다.

- (1) 복잡함을 잘 관리하기 위해
- (2) 형체가 없는 소프트웨어의 구조를 시각화하기 위해
- (3) 다른 사람과 커뮤니케이션 하기 위해
- (4) 문제 도메인 및 제품 요구 사항을 이해하기 위해
- (5) 개발 중인 시스템을 이해하기 위해
- (6) 구현하기 전에 잠재적 솔루션을 실험해보기 위해
- (7) 기존 시스템의 문서화



### 5.1.1 관점과 추상화 수준

- 모델은 복잡한 것을 추상화, 단순화하는 작업이다.
- 모델은 관점(perspective)과 추상화 수준(abstraction level)에 따라 달라지는데, 관점과 수준은 모델을 만드는 만드는 목적에 따라 결정된다.



### 5.1.2 소프트웨어 모델링

- 대부분의 소프트웨어 모델은 시각적 다이어그램이다.
- 소프트웨어를 모델링하는 관점에는 비지니스 프로세스, 구조, 동작이 있다.



### 5.1.3 모델 사이의 관계

- 모델링은 대상을 파악해 나가며 특정 관점에 해당하는 요소를 찾아내 시각적을 표현한 것이다. 발견된 요소는 다른 관점의 모델링에 영향을 줄 수 있다.
- 요구 모델에 표현한 의미는 더 구체화되어 설계 모델로 발전된다.



## 5.2 UML

- **UML(Unified Modeling Language)**: 소프트웨어 모델을 표현하기 위한 표기법 중 가장 보편적이다.



### 5.2.1 UML의 역사

UML 초안은 세 가지 객체 지향 방법론의 표기법이 결합되어 있다.

- (1) Grady Booch의 방법론
- (2) James Rumbaugh의 OMT(Object-Modeling Technique)
- (3) Ivar Jacobson의 OOSE(Object-Oriented Software Engineering)



### 5.2.2 UML 다이어그램

- UML로 두 가지 관점의 모델링을 할 수 있다.
  - **정적**: 시간 구성 요소가 없다.
  - **동적**: 시스템이 시간이 지남에 따라 어떻게 변하는지 보여준다.

- UML에는 크게 두 가지 다이어그램 유형이 있다.
  - **구조 다이어그램**(6개): <u>정적 관점</u>의 모델링
    - 클래스 다이어그램
    - 객체 다이어그램
    - 컴포넌트 다이어그램
    - 배치 다이어그램
    - 패키지 다이어그램
    - 컴포넌트 구조 다이어그램
  - **동작 다이어그램**(7개): <u>동적 관점</u>의 모델링
    - 유스케이스 다이어그램
    - 액티비티 다이어그램
    - 상태 다이어그램
    - **인터렉션(상호작용) 다이어그램**: 객체 간의 상호 작용을 설명한다.
      - 시퀀스 다이어그램
      - 커뮤니케이션 다이어그램
      - 인터렉션 오버뷰 다이어그램
      - 타이밍 다이어그램



### UML의 주요 다이어그램

| UML 다이어그램        | 설명                                                         | 모델링 적용                                                  |
| --------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 클래스 다이어그램     | - 방향 그래프<br />- 정점: 클래스, 클래스가 가진 속성과 연산의 정보<br />- 방향이 있는 간선: 클래스의 관계 | - 도메인 모델을 나타내는 데 사용<br />- 개발자가 도메인 개념과 이들 사이의 관계를 이해하고 전달하는 데 도움 |
| 배치 다이어그램       | - 정점: 분산 시스템의 물리적인 컴퓨팅 파워와 이 위에 실행되는 컴포넌트<br />간선: 네트워크 연결 | 분산 시스템의 각 컴퓨팅 노드, 컴포넌트, 커넥터 등 시스템의 물리적 자원 배치를 나타내는 데 사용 |
| 패키지 다이어그램     | - 정점: 패키지<br />- 방향이 있는 간선: 패키지의 의존관계    | 복잡한 클래스를 서브시스템으로 조직화하는 데 사용            |
| 유스케이스 다이어그램 | - 정점: 사용 사례(업무 프로세스), 액터<br />- 간선: 어떤 액터가 업무 프로세스와 상호작용하는지 나타냄 | - 현재 존재하는 애플리케이션이나 사용자가 개발을 요구한 시스템의 업무 프로세스 개관을 나타내는데 사용<br />- 시스템 또는 서브시스템의 범위를 나타냄 |
| 액태비티 다이어그램   | - 방향 그래프<br />- 정점: 정보를 처리하는 작업<br />- 방향이 있는 간선: 자료 및 제어 흐름을 나타냄<br />- 제어 흐름: 순차, 병렬, 동기화를 나타냄 | 시스템 또는 서브시스템의 복잡한 작업 흐름을 나타내는 데 사용 |
| 시퀀스 다이어그램     | - 정점: 객체<br />- 방향이 있는 간선: 객체 간에 오가는 메시지와 요구를 시간 순으로 나타냄 | - 시스템 안에 존재하는 객체들이 어떤 사용 사례(업무 프로세스)에 개입하여 어떻게 처리하는지 나타낸다.<br />- 개발팀이 현재의 업무 프로세스를 이해하는 데 도움이 됨 |



### 5.2.3 모델링 관점

- 모델링 작업의 목표: 시스템에 필요한 클래스와 그들의 관계를 찾아내는 것



#### 모델링 프로세스

- (1) 요구를 유스케이스로 정리하고 유스케이스 다이어그램을 작성
- (2) 클래스 후보를 찾아내고 개념적인 도메인 모델을 작성
- (3) 유스케이스에 기초하여 시퀀스 다이어그램 작성
- (4) 클래스의 속성, 연산 및 클래스 사이의 관계를 찾아내고 도메인 모델을 완성
- (5) 상태/액티비티 등 다른 다이어그램을 추가하여 UML 모델을 완성
- (6) 서브시스템을 파악하고 전체 시스템 구조를 설계
- (7) 적당한 객체를 찾아내거나 커스텀화 또는 객체를 새로 설계한다.



## 5.3 정적 모델링

- 정적 모델링: 객체들의 공통 구조와 동작들을 추상화한 것
  - 클래스 다이어그램: 특히 도메인 개념과 속성 및 관계를 나타내는 중요한 모델
  - 클래스 다이어그램 작성
    - 분류를 통하여 클래스를 작성
    - 분류 작업은 두 가지 방향으로 이루어진다.
      - 확정형(extensional): 개별 사례로부터 공통점을 찾는 것
      - 계획형(intentional): 일반적은 개념의 속성, 동작을 찾아 개별 사례에 적용해 나가는 것



### 5.3.1 객체지향 개념

- 객체(object): 상태, 동작, 고유 식별자를 가진 모든 것
  - 객체의 상태: 속성값에 의해 정의됨
- 클래스(class): 공통 속성을 공유하는 객체 집합에 대한 정의
- 속성과 연산: 객체가 가지는 속성(attribute), 객체가 수행할 수 있는 능력인 연산(operation)
- 캡슐화(encapsulation): 객체의 속성과 오퍼레이션을 하나로 모으는 것
  - 정보 은닉(information hiding): 캡슐 속에 있는 항목에 대한 정보를 외부에 감추는 것
- 연관(association): 두 클래스가 상호작용하는 경우, 클래스는 연관 관계에 있다.
  - 객체의 가시성(visibility): 두 객체가 연관이 있다면 서로를 알고 접근할 수 있어야 한다.
- 상속(inheritance): 상위의 일반화된 클래스가 가지는 속성과 연산을 하위의 구체화된 클래스가 물려받는 것
  - 서브 클래스(subclass): 세분화된 클래스들
  - 슈퍼 클래스(superclass): 원래의 클래스들
- 다형성(polymorphism): 하나의 연산이 여러 가지 형태를 가지고 있는 것



### 5.3.2 클래스 다이어그램

![클래스 다이어그램](https://user-images.githubusercontent.com/57662010/138893313-87299b50-7745-4701-b059-58f8ebe75513.png)

- 클래스 다이어그램: 시스템의 정적 측면을 모델링 한다.



#### 속성

```
가시성 / 변수이름: 타입 다수성=디폴트값 {속성}
```

- `가시성`: 속성에 대한 접근성
  - `+`: public
  - `-`: private
- `타입`: 클래스, 인터페이스, 정수 등
- `다수성`: 자료가 참조하는 객체의 수
- `디폴트`: 인스턴스가 생성될 때 속성에 할당되는 기본값
- `속성`: ordered, readOnly 등



#### 오퍼레이션

- 오퍼레이션: 동작에 대한 인터페이스
- 메서드: 오퍼레이션의 구현

```
가시성 오퍼레이션이름(매개변수, ): 리턴타입{속성}
```

- `매개변수`의 형식
  - `방향 매개변수이름 : 타입 = 디폴트값`
  - `방향`: in, out, inout 중 하나
- `속성`: 오퍼레이션의 추가 속성
  - `{query}`가 일반적: 오퍼레이션이 값을 반환하고 객체의 상태를 변화시키지 않음을 의미



#### 정적 속성과 오퍼레이션

- 정적 속성과 오퍼레이션은 밑줄을 그어 구별한다.



#### 관계

- 관계(relationship): 클래스 단위 또는 객체 사이의 관계이다.
- 관계에는 다음과 같은 종류가 있다.
  - (1) 연관
  - (2) 상속
  - (3) 의존
  - (4) 구현



#### 연관

- 연관: 객체 사이에 관련되어 있음
  - 시간이 흘러도 유지되는 관계이다.
- 두 클래스 사이의 실선으로 표시한다.
  - 방향이 있으면 단방향으로만 탐색 가능
  - 방향이 없으면 양방향으로 탐색 가능
- 다중성 표현: 10명에서 30명 까지의 학생이 0 개 이상의 강의와 연관



#### 상속

- 구체적인 클래스에서 일반적인 클래스로 화살표가 향한다.



#### 의존

- 의존(dependency): 한 클래스의 변경으로 다른 클래스의 변경이 필요할 수 있다.
  - 네 가지 관계 중 결합력이 가장 약하다.



#### 구현

- 구현: 클래스가 인터페이스를 구현하는 것





## 5.4 동적 모델링

- 소프트웨어의 동적 측면: 소프트웨어가 실행될 때 변경될 수 있는 뷰로, 시간의 함수로만 이해할 수 있다.
- 동적 다이어그램은 정적인 클래스 다이어그램을 보완한다.
  - 클래스 다이어그램: 소프트웨어의 정적 구조를 모델링
  - 상호작용 다이어그램: 동적 동작을 모델링. 
- 상호작용 다이어그램: 런타임에 객체가 어떻게 작동하여 결과를 완료하는지 보여준다. 다양한 추상화 수준에서 시스템 동작을 모델링할 수 있다. 일반적으로 다음과 같은 동작을 모델링할 때 사용한다.

- - (1) **시스템 전체 동작**: 시스템 전체 수준의 동작을 설명한다.
  - (2) **오퍼레이션**: 주어진 시간 동안 발생하는 메서드 호출의 순서를 보여준다.
- UML은 두 가지 유형의 상호작용 다이어그램을 제공한다.
  - (1) **시퀀스 다이어그램**: 메시지의 상대적 순서를 더 쉽게 볼 수 있다.
  - (2) **협동 다이어그램**: 상호작용과 관련된 모델 요소 간의 구조적 관계를 더 쉽게 볼 수 있다.



### 5.4.1 시퀀스 다이어그램

**시퀀스 다이어그램**은 메시지 교환을 시간적 관계로 나타낸다.

- 시간
  - 다이어그램의 수직축
  - 위에서 아래로 흐른다.
- 객체
  - 다이어그램의 수평축에 따라 상단에 나열
  - 상호작용에 참여하는 객체(participating object)
- 객체의 표현
  - 기본적으로 `객체 이름: 클래스 이름` 형식으로 표현
  - `:Person` : `Peson` 클래스의 이름 없는 인스턴스
  - `kim:`: 이름 없는 클래스의 `kim`이라는 인스턴스
  - 인스턴스 박스가 여러 개: 인스턴스의 모임
- 라이프 라인
  - 객체가 연결된 수직 점선
  - 객체가 존재하는 기간
- 활성 박스(activation box)
  - 수직 점선 위의 막대
  - 메서드가 활성되는 기간
- 시퀀스 다이어그램에서 메시지의 전달은 나열된 순서를 따른다.



#### 5.4.1.1 작성 과정

- 시퀀스 다이어그램은 여러 객체 사이의 상호 작용을 표시한다.
  - 유스케이스의 이벤트 흐름을 나타내는데 사용된다.
  - 유스케이스에 참여하는 객체를 찾아낸다.
  - 유스케이스 명세에 표현된 동작을 시스템 내부에 존재하는 객체의 메시지 교환 형태로 표현하는데 사용한다.
- 시퀀스 다이어그램의 작성 과정
  - (1) 참여하는 객체를 파악한다.
  - (2) 파악한 객체를 X축에 나열하고 라이프라인을 긋는다.
  - (3) 유스케이스에 기술된 이벤트 순서에 따라 객체의 메시지 호출을 화살표로 나타낸다.
    - 유스케이스를 구동시키는 액터로부터 UI 클래스에 보내는 명령을 표시한 한다.
    - 개입하는 각 객체의 메시지 호출을 화살표로 그린다.



#### 5.4.1.2 사례

- (1) '수강 신청' 유스케이스에 참여하는 객체를 찾는다.
  - GUI를 담당하는 객체: 수강 신청을 위해 신청 과목을 선택받는다.
    - `CourseSection`에 `requestToRegister()` 메시지를 보내어 학생을 등록한다.
  - `Registration` 객체: 등록 정보를 기록하는 객체



### 5.4.2 협동 다이어그램

- **협동 다이어그램**은 상호작용에 참여하는 객체의 정적인 구조를 더 잘 보여준다.

- 협동 다이어그램은 다음 두 가지를 조합한 것이다.
  - (1) 상호작용에 필요한 객체들 간의 링크를 포함한 객체 다이어그램
  - (2) 상호작용을 정의하는 객체 간의 메시지
- 링크: 메시지가 이동할 수 있는 경로
  - 클래스 다이어그램에서 클래스에 연관이 있다면 협동 다이어그램에서 객체 간에 링크가 있음
- 협동 다이어그램에서 메시지의 전달 순서는 각 메시지 앞에 표시된 번호로 결정



### 5.4.3 상태 다이어그램

**상태 다이어그램**은 시스템의 동작을 수신 이벤트와 이에 대한 응답에 기반하여 상태 사이의 전환으로 모델링한다.

- 상태 모델링을 작성할 때 고려할 것
  - 어떤 외부 자극이 관심의 대상이며 영향 받는 객체의 상태는 무엇인가: 서브시스템이나 객체가 어떤 상태를 가질 수 있는지
  - 상태 종속적인 객체의 반응이 어떻게 변환하는가: 어떤 상태에서 어떤 이벤트에 의해 어떤 상태로 변환하는지
  - 상태를 체크하기 위한 속성의 조건은 무엇인가: 그러한 상태에 들어가게 하는 조건(외부 이벤트나 오퍼레이션)이 무엇인지



## 5.5 제어 모델링

**액티비티 다이어그램**은 알고리즘이나 프로세스에서 작업 절차를 모델링한다.

- 상호작용 다이어그램을 보완한다: 상호작용 다이어그램은 객체에서 객체로의 제어 흐름을 모델링하고 액티비티 다이어그램은 액티비티의 흐름을 모델링한다.
- 액티비티 다이어그램을 언제 사용하는가
  - 객체가 식별되기 전 액티비티로 모델링하고 식별된 객체에 액티비티를 나중에 할당하는 형태로 사용한다.
  - 문제 영역의 워크플로와 솔루션 도메인의 소프트웨어 제어흐름을 모델링할 때 사용된다.
- 액티비티: 계산 또는 프로세스
- 전환: 하나의 액티비티에서 다른 액티비티로 제어가 넘어간다는 것을 나타낸다.
- 분기 및 병합 다이아몬드: 조건부 제어 흐름을 모델링하는데 사용
- 분기에서 나가는 전환: 진위 조건을 표시
- 스윔레인
  - 액티비티는 스윔레인으로 분할된다.
  - 각 액티비티를 책임질 구성 요소 또는 조직 단위를 나타낸다.
  - 액티비티에 대한 책임을 할당할 수 있다.
- 병렬 액티비티: 뱅렬 수행을 표현한 액티비티 다이어그램
  - 포크 및 조인 표기법으로 나타낸다.



## 5.6 모델 검증

- **검증**은 사용자 요구가 요구분석 명세서에 올바르게 기술되었는지 검토하는 활동이다.



### 5.6.1 모델 검증 방법

모델 검증 방법은 여러 가지가 있다.

- (1) **리뷰**: 워크스루, 인스펙션 등 사람이 눈으로 확인한다. 체크리스트를 이용한다.
- (2) **테스팅**: 모델에 근거하여 테스트 데이터를 찾아내고 구현 후 테스팅한다.
- (3) **정형적 방법**: 요구가 정확하고 모델이 일관성이 있음을 수학적으로 증명한다.
  - 예) 상태 다이어그램에서 각 상태에 대한 조건을 식으로 나타내어 변환 과정을 검증
- (4) **프로토타이핑**: 예상대로 동작함을 보이기 위해 모델을 기반으로 프로토타입 제작
- (5) **요구 추적**: 모델로부터 요구를 거꾸로 추적한다.



### 5.6.2 일관성 체크

![5.5 체크리스트](image\5.5 체크리스트.jpg)

- UML 다이어그램 사이에 불일치하는 부분이 없는지 교차하여 검토한다.

  - (1) 유스케이스 다이어그램과 시퀀스 다이어그램: 각 유스케이스에 대한 명세가 기술되어 있고 매칭되는 시퀀스 다이어그램이 있는지 체크

    - (1) 각 액터에 적어도 하나 이상의 유스케이스가 있는가

    - (2) 각 유스케이스를 구동하는 액터가 있는가

    - (3) 각 유스케이스에 대한 명세가 기술되었나

      해당하는 시퀀스 다이어그램이 있는가

  - (2) 시퀀스 다이어그램과 클래스 다이어그램: 시퀀스 다이어그램의 클래스와 메시지가 클래스 다이어그램에 누락되지  않았는지 체크

    - 메시지를 받는 클래스에 메서드의 정의가 되어 있는 확인
    - (1) 모든 클래스가 클래스 다이어그램에 포함되어 있는가
    - (2) 시퀀스 다이어그램에 표현된 각 메서드에 대하여
      - (1) 메시지를 보내는 클래스와 받는 클래스가 클래스 다이어그램에서 연결되어 있는가
      - (2) 메시지를 보내는 클래스 안에 메시지의 호출이 있는가
      - (3) 메시지를 받는 클래스 안에 메시지의 정의가 있는가

  - (3) 상태 다이어그램과 클래스 다이어그램: 클래스 `A`의 한 상태에서 다른 상태로 전환되는 것은 클래스 `A`의 메서드 호출에 의해 발생하므로 `A` 클래스 안에 그러한 메서드를 정의해야 한다.



