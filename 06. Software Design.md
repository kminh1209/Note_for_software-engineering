# 06. Software Design

- 설계 작업은 시스템의 논리 구성을 결정하는 것이다.
- 제안된 설계는 문제에 대한 솔루션이며, 완성된 세계는 요구를 만족하는 특정한 솔루션이라 할 수 있다.
- 설계 작업은 다음과 같이 나눌 수 있다.
  - (1) **기본 구조 설계**: 아키텍처 설계로 각 모듈의 역할과 인터페이스를 정의한다.
  - (2) **상세 설계**: 모듈 내부의 알고리즘, 데이터를 명세화한다.



## 6.1 설계 기본 개념

- 전통적인 설계 방법은 분할 정복, 추상화, 합성 등의 원리를 적용하였으나, 최근에는 아키텍처를 고려하여 설계한다. 복합한 문제를 다루고 변경에 잘 대처할 수 있기 때문이다.



### 6.1.1 서브시스템, 모듈

- 아키텍처는 시스템을 구성하는 컴포넌트와 컴포넌트 상호작용의 집합이다.
  - 컴포넌트: 독립적으로 취급될 수 있는 단위, 서브시스템 또는 모듈
  - 서브시스템: 클래스의 모임으로 패키지이다.
    - 다른 서브시스템과 상호작용하기 위해 정의된 인터페이스를 가진다.
- 서브시스템으로 분할하는 것의 장점
  - 개발자의 커뮤니케이션이 줄어든다.
  - 수정에 대한 영향을 덜 받는다.



| 개념       | 설명                                                         |
| ---------- | ------------------------------------------------------------ |
| 컴포넌트   | - 독립적으로 존재할 수 있는 시스템의 부분<br />- 명백한 역할을 가짐<br />- 재사용가능하도록 설계되나, 특정한 목적만을 수행하기 위해 설계되기도 함<br />- 프레임워크는 컴포넌트의 한 종류 |
| 모듈       | - 프로그래밍 언어의 문법 구조에서 정의된 컴포넌트<br />- 프로그래밍 언어로 작성된 문법 단위에 한정하여 사용함<br />- 예) 자바의 모듈: 메서드, 클래스, 패키지 / C의 모듈: 파일과 함수 |
| 서브시스템 | - 여러 다른 방법들로 구현될 객체를 나타낸다.<br />- 컴포넌트들이 시간에 따라 변하거나 다른 컴포넌트로 교체되어도 지속적으로 존재한다. |



### 6.1.2 설계 관점

아키텍처 설계에는 세 가지 관점이 있다.

- (1) **모듈 관점**: 모듈(일정한 책임을 구현한 코드 단위)과 그 관게로 소프트웨어 구조를 설명하는 관점
- (2) **컴포넌트 관점**: 실행될 때 동작하는 요소와 상호작용으로 구조를 설명하는 관점
- (3) **할당 관점**: 소프트웨어의 하드웨어 설치, 작업 할당, 구현, 데이터 저장 등에 대한 관점



| 측면          | 설계 스타일                                                  |
| ------------- | ------------------------------------------------------------ |
| 모듈 측면     | 분할, 사용 관계, 계층 구조, 데이터 모델                      |
| 컴포넌트 측면 | 클라이언트 서버, 파이프필터, 출판 구독, 이벤트 중심, 리파지토리 |
| 할당 측면     | 배치, 설치, 작업 할당, 구현, 데이터 저장                     |



### 6.1.3 설계 작업 과정

일반적인 설계 과정은 다음과 같다.

- (1) **설계 목표 설정**: 전체 시스템에 대한 설계 목표를 파악하고 결정한다.
  - 예) 전화 교환 시스템: 고장에 대한 내성(fault tolerance), 안전과 보안, 최대 성능
- (2) **스타일 결정**: 시스템이나 서브시스템의 타입을 결정하기 위해 설계 목표와 유형에 맞은 아키텍처 스타일을 선택한다.
- (3) **서브시스템의 기능, 인터페이스 명세**: 서브시스템 사이의 인터페이스를 정의하고 서브시스템 사이의 상호작용을 위한 동작을 작성한다.
- (4) **아키텍처 설계 검토**: 설계한 아키텍처가 요구, 설계 목표, 설계 원리를 잘 만족하는지 검토한다.



## 6.2 품질 목표

**비기능 요구 사항(Non-functional requirements)**: 품질 특성으로, 시스템 설계안을 결정하는 요소들이다.



ISO 25010이 정의하는 소프트웨어의 기능 외적인 품질은 다음과 같다.

![6.2_2](image\6.2_2.jpg)

![6.2_1](\image\6.2_1.jpg)



## 6.3 전통적인 설계 원리

전통적으로 소프트웨어를 설계할 때 다음 특성을 중요하게 다룬다.

- **효율성(efficiency)**: 시스템이 사용하는 자원이 적정하고 효과적임을 의미한다.
  - 비용 절약 측면에서 다룬다.
  - 일반적으로 처리 시간과 기억 공간에 대해 효율성을 고려한다.
- **단순성(simplicity)**: 설계가 단순하여 이해하기 쉬움을 의미한다.



### 6.3.1 추상화

**추상화(abstraction)**: 대상에 대하여 특정한 목적에 관련한 정보에 집중, 나머지 정보는 무시하는 관점이다.

- 컴포넌트의 추상: 컴포넌트가 어떻게 동작하는지 내부의 상세한 사항에 구애받지 않고 외부에 보이는 동작을 나타내는 것
- 문제 분할의 근본: 분할은 복잡한 시스템을 구성요소로 자르는 과정이다. 다른 컴포넌트와 어떻게 상호작용 하는지 결정하기 위해 외부에 보이는 동작을 잘 나타내는 추상화가 필요하다.



### 6.3.2 캡슐화

**캡슐화**: 추상화된 대상이 제공하는 서비스를 쉽게 접근하게 하는 개념

- **정보 은닉(information hiding)**: 자세한 내부 구현을 외부에 드러내지 않고 숨긴다.
  - 어떻게 데이터를 저장하는지
  - 데이터를 어떻게 처리하는지
  - 특정 기능을 어떻게 제공하는지
- 정보 은닉이 잘되면 내부의 변화가 외부의 내용에 영향을 미치지 않는다.



### 6.3.3 모듈화

**모듈화**: 문제를 소프트웨어의 구성요소가 될 만한 수준으로 분할하는 과정

- 소프트웨어를 작은 구성 요소(패키지 또는 클래스)로 나누는 것
- 모듈화의 장점
  - 각각의 모듈을 별개로 만들고 수정할 수 있다.
  - 모듈을 별도로 컴파일할 수 있다면 하나를 수정해도 전체를 컴파일할 필요가 없다.
  - 모듈을 수정해도 다른 부분에 영향을 적게 주어 디버깅에 도움이 된다.
- 모듈화의 단점
  - 너무 세부적으로 쪼개면 어떻게 상호작용하는지 이해하는 것이 어려울 수 있다.



### 6.3.4 결합

**결합(coupling)**: 모듈 간에 서로 의존하는 정도를 뜻한다.

- 좋은 소프트웨어는 낮은 결합력을 가진다.

모듈 간의 결합 정도는 다음 두 가지 요소로 결정된다.

- (1) 모듈 간 인터페이스 수
- (2) 각 인터페이스의 복잡성(통신 유형에 따라 결정됨)

모듈 사이의 결합은 정도에 따라 다섯 가지로 나눌 수 있다.

- (1) **내용 결합(content coupling)**: 한 모듈이 다른 모듈의 내용을 직접 참조하는 경우 발생한다.
- (2) **공통 결합(common coupling)**: 한 모듈이 다른 모듈이 읽은 전역 변수 값을 쓰거나 변경한 경우 발생한다.
- (3) **제어 결합(control coupling)**: 한 모듈이 다른 모듈의 제어 흐름을 결정하는 경우 발생한다.
- (4) **스탬프 결합(stamp coupling)**: 복합 데이터 구조의 일부만 사용하는 모듈에 복합 데이터 구조를 전달할 대 발생한다.
  - 예) 세 개의 필드가 있는 레코드에서 두 개의 필드만 필요한 모듈에 레코드를 매개변수로 전달하는 경우
- (5) **데이터 결합(data coupling)**: 모듈들이 주고받는 매개변수가 간단한 타입이거나 레코드 안의 필드여도 단순 타입인 경우에 해당한다.



### 6.3.5 응집

**응집(cohesion)**: 하나의 모듈 안에서 수행되는 작업들이 서로 관련된 정도를 듯한다.

- 응집과 결합의 차이
  - 응집: 모듈, 클래스, 컴포넌트 안의 모든 요소가 하나의 기능 단위로써 협동하는 정도. 높은 응집이 바람직하다.
  - 결합: 둘 이상의 모듈, 클래스, 컴포넌트 사이에 서로 의존하는 정도. 느슨한 결합이 바람직하다.



응집의 정도는 오름차순으로 다음과 같다.

- **우연적(coincidental) 응집**: 요소들이 의미적으로 아무런 관계가 없다.
- **논리적(logical) 응집**: 같은 범주의 기능을 수행하여 그룹으로 묶였으나 본질적으로 다르다.
- **시간적(temporal) 응집**: 프로그램 실행의 특정한 시간에 처리되어 한 그룹 안에 모여있다.
- **절차적(procedural) 응집**: 모듈 안에서 수행되는 연산이 프로그램에서 수행되는 순서와 관련이 있다.
- **교환적(communicational) 응집**: 요소들이 동일한 데이터를 조작하여 한 그룹 안에 모여있다.
- **기능적(functional) 응집**: 요소들이 모듈에 대하여 정의된 하나의 기능에 모두 기여하고 밀접하게 관련되어 한 그룹 안에 모여있다.
- **정보적(informational) 응집**: 여러 가지 연산을 수행하나, 각 연산이 각각 고유한 시작점과 독립된 코드가 있으며 모든 연산이 같은 데이터에 대해 실행된다.



## 6.4 객체지향 설계 원리

객체 지향의 설계 원칙 5가지는 다음과 같다.

- 단일 책임의 원리(Single Responsibility Principle)
- 개방 폐쇄의 원리(Open Close Principle)
- 리스코프 교체의 원리(Liskov Substitution Principle)
- 인터페이스 분리의 원리(Interface Segregation Principle)
- 의존관계 역전의 원리(Dependency Inversion Principle)



### 6.4.1 인터페이스와 구현의 분리

- 인터페이스: 공개된 메서드의 프로토타입만을 정의해 놓은 것
- 인터페이스와 구현의 분리 원칙: 컴포넌트의 공개 인터페이스를 컴포넌트가 어떻게 구현되는지 상세하게 나타낸 것과 분리한다.
- 인터페이스 분리와 캡슐화
  - 캡슐화: 구현 세부 사항을 숨겨야 한다.
  - 인터페이스 분리: 동일한 인터페이스의 다른 구현을 교환하여 수정하거나 새로운 동작을 제공할 수 있도록 한다.



### 6.4.2 단일 책임의 원리

- 단일 책임의 원리: 클래스의 역할과 책임을 단일화한다.



### 6.4.3 개방 폐쇄의 원리

- 개방 폐쇄 원칙: 소프트웨어 개체(클래스, 모듈, 기능 등)가 확장을 위해서 열려있어야 하나 수정을 위해서는 닫혀야 한다.
- 다형성
  - 상속을 이용하여 클래스가 정의되어 있을 때 다형성이 적용되어 서로 대체할 수 있는 인터페이스를 구현할 수 있다.
  - 클래스 자체를 수정하지 않고 클래스를 확장할 수 있다.



### 6.4.4 리스코프 교체의 원리

- 리스코프 교체의 원칙: 하위 클래스(파생 클래스)가 기본, 부모 클래스로 대체 가능해야 한다.



### 6.4.5 인터페이스 분리의 원리

- **비만 인터페이스(fat interface)** 또는 **오염된 인터페이스(polluted interface)**: 전체 인터페이스에 의존하게 하되 사용하지 않는 일부 메서드에 대하여 더미 메서드를 구현한 것
- 인터페이스 분리 원칙: 클라이언트가 사용하지 않는 인터페이스를 강제로 구현해서는 안된다.
  - 다수의 작은 인터페이스를 만들어 필요한 것만 사용하도록 유도해야 한다.
  - 예) `Animal` 클래스의 `walk` 메서드는 새에게 적용될 수 없으므로 완벽한 추상화가 아니다. `CanWalk()` 인터페이스를 정의하는 것이 바람직한다.



### 6.4.6 의존 관계 역전의 원리

- 의존 관계 역전 원칙: 높은 수준의 모듈은 재사용이 가능하고 유틸리티 기능을 제공하는 낮은 수준의 모듈 변경에 의해 쉽게 영향을 받지 않아야 한다.
  - 높은 수준의 모듈과 낮은 수준의 모듈을 서로 분리하는 추상화를 도입해야 한다.
  - 낮은 수준의 모듈(구체화된 모듈)이 추상화된 모듈(높은 수준의 모듈)에 의존해야 한다.



## 6.5 설계 메트릭

### 6.5.1 전통적인 메트릭

모델에 대한 전통적인 측정 방법으로 다음과 같은 특성 메트릭이 있다.

- **크기**: 시스템 규모를 하나의 메트릭으로 측정한다. 다음과 같은 방법이 있다.
  - 모듈의 개수를 센다.
  - 모듈 사이의 인터페이스 수를 센다.
  - 클래스 안에 몇 개의 속성과 연산이 있는 센다.
- **복잡도**: 얼마나 서로 연관되어 복잡한지를 나타낸다. 구조, 데이터, 시스템 관점의 복잡도를 다음의 식으로 측정할 수 있다.
  - (1) 머듈의 구조적 복잡도 = (모듈의 팬 아웃 개수)^2
  - (2) 데이터 복잡도 = (입력 및 출력 변수의 개수) / (팬 아웃 + 1)
  - (3) 시스템 복잡도 = 구조적 복잡도 + 데이터 복잡도
- **결합도**: 모듈이 어느 정도 연결되어 있는지 나타낸다.
  - 입출력 매개변수, 전역 변수, 호출된 모듈 개수의 함수이다.
- **응집도**: 오퍼레이션이 얼마나 잘 협동하는지 나타낸다.
  - 데이터 객체와 정의된 위치의 함수이다.
- **정보 흐름**: 얼마나 많은 정보가 처리되어 흘러가는지 나타낸다.
  - 전달하는 매개변수, 전역 변수, 입출력의 개수 혹은
  - 팬 인(모듈이 호출되는 횟수), 팬 아웃(다른 모듈을 호출하는 횟수)



### 6.5.2 객체지향 메트릭

Chidamber와 Kemerer의 메트릭

![6.5 객체지향 설계 메트릭](\image\6.5 객체지향 설계 메트릭.jpg)

